## A.Zhan's Blander

如果 $y\le x$， 每次放进去的 $y$ 个水果都能搅拌完，答案为 $\lfloor \dfrac{n}{y} \rfloor$；如果 $y > x$，每次即便放进去多于 $x$ 个也搅拌不完，所以直接每次放进去 $x$ 个，答案为 $\lfloor \dfrac{n}{x} \rfloor$，所以答案为 $\lfloor \dfrac{n}{\min(x,y)} \rfloor$。特判 $n=0$ 是答案为 0。

## B. Battle for Survive

因为对波左必输，所以赢家一定是 $n$。考虑最小化 $a_{n-1}$，只需让 $n-1$ 先和前面每个人打过，最大程度削弱 $a_{n-1}$。$a_n-a_{n-1}$ 即为答案。

## C. Password Cracking

维护一个空字符串，首先判断 `？ 0`，如果返回 0 则输出 $n$ 个 1，否则 `s += '0'` 并测试**后一位**是什么：
- `? 00`，返回 1 则 `s += '0'`；
- 若返回 0，继续判断 `? 01`，返回 1 则 `s += '1'`。

以此类推，判断后面每一位是什么，直到末尾。这时候无论在后面加 0 还是 1 都会返回 0，我们退出循环，再从起始位置向前判断每一位是什么。

按照这种构造方法，最坏情况下，开始位置我们判断了 1 次，后续每个位置判断 2 次，多判断 2 次发现到达终点，前面每个位置（除第一位）判断 2 次，第一位只需要判断 0 不用判断 1，再加 1 次，共 $2n$ 次，符合条件。

## D. Minimize the Difference

发现同时最大化最小值和最小化最大值是可能的：减小最大值，不会减小其他的点；增大最小值，不会增大其它的点。所以可以直接分别二分出最大值和最小值，相减即可。

## E. Prefix GCD

注意到 $n$ 个数的 $\gcd$ 个数是 $\log n$ 级别的，所以只需要大概 10 个数 $\gcd$ 就会变成 0。考虑一个贪心：每次暴力枚举使得 $\gcd(a_1,a_2\cdots a_k)$ 最小的 $a_k$，直到 $\gcd$ 变成 0，全部加上输出。